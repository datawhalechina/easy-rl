# MDP

![](img/2.1.png)

这节课我会给大家介绍马尔可夫决策过程。

* 在介绍马尔可夫决策过程之前，先介绍它的简化版本：马尔可夫链以及马尔可夫奖励过程，通过跟这两种过程的比较，我们可以更生动地理解马尔可夫决策过程。
* 第二部分会介绍马尔可夫决策过程中的 `policy evaluation`，就是当给定一个决策过后，怎么去计算它的价值函数。
* 第三部分会介绍马尔可夫决策过程的控制，具体有两种算法：`policy iteration` 和 `value iteration`。

![](img/2.2.png)

上图介绍了在强化学习里面 agent 跟 environment 之间的交互，agent 在得到环境的状态过后，它会采取行为，它会把这个采取的行为返还给环境。环境在得到 agent 的行为过后，它会进入下一个状态，把下一个状态传回 agent。在强化学习中，agent 跟环境就是这样进行交互的，这个交互过程是可以通过马尔可夫决策过程来表示的，所以马尔可夫决策过程是强化学习里面的一个基本框架。在马尔可夫决策过程中，它的环境是 `fully observable` ，就是全部可以观测的。但是很多时候环境里面有些量是不可观测的，但是这个部分观测的问题也可以转换成一个 MDP 的问题。

![](img/2.3.png)

在介绍马尔可夫决策过程之前，先给大家梳理一下马尔可夫、马尔可夫奖励过程。这两个过程是马尔可夫决策过程的一个基础。

## Markov Process(MP)

![](img/2.4.png)如果一个状态转移是符合马尔可夫的，那就是说一个状态的下一个状态只取决于它当前状态，而跟它当前状态之前的状态都没有关系。比如说我们这里有一个 $h_t$，它包含了之前的所有状态。但是这里的转移从当前 $s_t$ 转到 $s_{t+1}$ 这个状态，它是直接就等于它之前所有的状态。如果某一个过程满足`马尔可夫性质(Markov Property)`，就是说未来的转移跟过去是独立的，它只取决于现在。**马尔可夫性质是所有马尔可夫过程的基础。**

![](img/2.5.png)

首先看一看`马尔可夫链(Markov Chain)`。举个例子，这个图里面有四个状态，这四个状态从 $s_1,s_2,s_3,s_4$ 之间互相转移。比如说从 $s_1$ 开始， $s_1$ 有 0.1 的概率继续存活在 $s_1$ 状态。另外，它有 0.2 的概率转移到 $s_2$ ，有 0.7 的概率转移到 $s_4$ 。如果 $s_4$ 是我们当前状态的话，那么它有 0.3 的概率转移到 $s_2$ ，有 0.2 的概率转移到 $s_3$ ，另外有 0.5 的概率留在这里。

我们可以用`状态转移矩阵(State Transition Matrix)`来描述这样的状态转移。状态转移矩阵类似于一个 conditional probability，当我们知道当前我们在 $s_t$ 这个状态过后，到达下面所有状态的一个概念。所以它每一行其实描述了是从一个节点到达所有其它节点的概率。

![](img/2.6.png)

上图是一个马尔可夫链的例子，我们这里有七个状态。比如说从 $s_1$ 开始到 $s_2$ ，它有 0.4 的概率，然后它有 0.6 的概率继续存活在它当前的状态。 $s_2$ 有 0.4 的概率到左边，有 0.4 的概率到 $s_3$ ，另外有 0.2 的概率存活在现在的状态，所以给定了这个状态转移的马尔可夫链后，我们可以对这个链进行采样，这样就会得到一串的轨迹。

下面我们有三个轨迹，都是从同一个起始点开始。假设还是从 $s_3$ 这个状态开始，

* 第一条链先到了 $s_4$， 又到了 $s_5$，又往右到了 $s_6$ ，然后继续存活在 $s_6$ 状态。
* 第二条链从 $s_3$ 开始，先往左走到了 $s_2$ 。然后它又往右走，又回到了$s_3$ ，然后它又往左走，然后再往左走到了 $s_1$ 。
* 通过对这个状态的采样，我们生成了很多这样的轨迹。

## Markov Reward Process(MRP)

![](img/2.7.png)

我们再来看一看`马尔可夫奖励过程(Markov Reward Process, MRP)`。MRP 是马尔可夫链再加上了一个奖励函数。在 MRP中，转移矩阵跟它的这个状态都是跟马尔可夫链一样的，多了一个`奖励函数(reward function)`。**奖励函数是一个期望**，就是说当你到达某一个状态的时候，可以获得多大的奖励，然后这里另外定义了一个 discount factor $\gamma$ 。

![](img/2.8.png)

这里是我们刚才看的马尔可夫链，如果把奖励也放上去的话，就是说到达每一个状态，我们都会获得一个奖励。这里我们可以定义比如说到达 $s_1$ 状态的时候可以获得 5 的奖励，到达 $s_7$ 的时候，它有 10 的奖励，其它状态没有任何奖励。因为这里状态是有限的，所以我们可以用一个向量来表示这个奖励函数，这个向量表示了每个点的奖励的大小。

我们可以通过一个形象的例子来理解 MRP，你可以把它看成一个纸船。我们把一个纸船放到河流之中，那么它就会随着这个河流而流动，它自身是没有动力的，所以你可以把 MRP 看成是一个随波逐流的例子，当我们从某一个点开始的时候，这个纸船就会随着事先定义好的状态转移进行流动，它到达每个状态过后，我们就有可能获得一些奖励。

![](img/2.9.png)

这里我们进一步定义一些概念。

* 第一个是 `horizon` ，它说明了同一个 episode 或者是整个一个轨迹的长度，它是由有限个步数决定的。
* 这里我们再定义一个 `return`。Return 说的是我们把奖励进行折扣，然后获得的这个收益。Return 可以定义为奖励的逐步叠加，然后这里有一个叠加系数，就是越往后得到的奖励，折扣得越多。这说明我们其实更希望得到现有的奖励，未来的奖励就要把它打折扣。
* 当我们有了这个 return 过后，就可以正式定义一个状态的价值了，就是 `state value function`。然后对于这个MRP，它里面定义成是关于这个 return 的期望， $G_t$ 是我们之前定义的 discounted return。然后我们这里取了一个期望，期望就是说从这个状态开始，你有可能获得多大的价值。所以这个期望也可以看成是一个对未来可能获得奖励的它的当前价值的一个表现。就是当你进入某一个状态过后，你现在就有多大的价值。

![](img/2.10.png)这里我们简短地解释一下为什么需要 discounted factor。

* 第一点是有些马尔可夫过程是带环的，它并没有终结，我们想避免这个无穷的奖励。
* 另外，我们想把这个不确定性表示出来，希望尽可能快地得到奖励，而不是在未来某一个点得到奖励。
* 另外如果这个奖励是有实际价值的了，我们可能是更希望立刻就得到奖励，而不是后面再得到奖励。
* 在人的行为里面来说的话，大家也是想得到即时奖励。
* 另外，在有些时候，这个系数也可以把它设为 0。比如说，当我们设为 0 过后，然后我们就只关注了它当前的奖励。我们也可以把它设为 1，设为 1 的话就是对未来并没有折扣，未来获得的奖励跟我们当前获得的奖励是一样的。这个系数其实是应该可以作为强化学习 agent 的一个 hyper parameter 来进行调整，然后就会得到不同行为的 agent。

![](img/2.11.png)

这里我们再来看一看，在这个 MRP 里面，如何计算它的价值。这个 MRP 依旧是这个状态转移。它的奖励函数是定义成这样，它在进入第一个状态的时候会得到 5 的奖励，进入第七个状态的时候会得到 10 的奖励，其它状态都没有奖励。

我们现在可以计算每一个轨迹得到的奖励，比如我们对于这个 $s_4,s_5,s_6,s_7$ 轨迹的奖励进行计算，这里折扣系数是 0.5。我们在 $s_4$ 的时候，奖励为零。下一个状态 $s_5$ 的时候，因为我们已经到了下一步了，所以我们要把 $s_5$ 进行一个折扣，$s_5$ 本身也是没有奖励的。然后是到 $s_6$，也没有任何奖励，折扣系数应该是 $\frac{1}{4}$ 。到达 $s_7$ 后，我们获得了一个奖励，但是因为 $s_7$ 这个状态是未来才获得的奖励，所以我们要进行三次折扣。所以对于这个轨迹，它的 return 就是一个 1.25，类似地，我们可以得到其它轨迹的 return 。

这里就引出了一个问题，当我们有了一些轨迹的实际 return，怎么计算它的价值函数。比如说我们想知道 $s_4$ 状态的价值，就是当你进入 $s_4$ 后，它的价值到底如何。一个可行的做法就是说我们可以产生很多轨迹，然后把这里的轨迹都叠加起来。比如我们可以从 $s_4$ 开始，然后采样生成很多轨迹，然后都把它的 return 计算出来，然后可以直接把它取一个平均来作为你进入 $s_4$ 它的价值。这其实是一种计算价值函数的一个办法，通过这个蒙特卡罗采样的办法计算 $s_4$ 的状态。接下来会进一步介绍这个蒙特卡罗算法。

![](img/2.12.png)

但是这里我们采取了另外一种计算方法，我们通过一定的推导就可以从这个价值函数里面推导出 `Bellman Equation（贝尔曼等式）`。**Bellman Equation 定义了当前状态跟未来状态之间的这个关系**。比如 $s'$ 我们可以把它看成未来的所有状态。然后这里有一个转移 $P(s'|s)$  ，就是我们从当前状态转移到未来状态，那么它之间是满足于这个关系。然后我们可以把第二部分看成是一个 Discounted sum of future reward。$V(s')$ 代表的是未来某一个状态的价值，那么我们从当前这个位置开始有一定的概率去到未来的所有状态，所以我们要把这个概率也写上去，这个转移矩阵也写上去，然后我们就得到了未来状态。然后再乘以一个 $\gamma$。这样就可以把未来打折扣，然后再加上当前立刻可以得到的这个奖励，这样就组成了这个 Bellman Equation。这个推导过程，大家其实可以去练习练习，就从这个定义出发，然后把它分解开，我们就可以得到 Bellman Equation。

>Bellman Equation 就是当前状态与未来状态的迭代关系，表示当前状态的值函数可以通过下个状态的值函数来计算。Bellman Equation 因其提出者、动态规划创始人 Richard Bellman 而得名 ，也 叫作“动态规划方程”。

![](img/2.13.png)

Bellman Equation 定义了状态之间的迭代关系。假设有一个马尔可夫转移矩阵是右边这个样子。Bellman Equation 描述的就是当前状态到未来状态的一个转移。假设我们当前是在 $s_1$， 那么它只可能去到三个未来的状态：有 0.1 的概率留在它当前这个位置，有 0.2 的概率去到 $s_2$ 状态，有 0.7 的概率去到 $s_4$ 的状态，所以我们要把这个转移乘以它未来的状态的价值，再加上它的 immediate reward 就会得到它当前状态的价值。所以 Bellman Equation 定义的就是当前状态跟未来状态的一个迭代的关系。

![](img/2.14.png)

我们可以把 Bellman Equation 写成一种矩阵的形式。首先有这个转移矩阵。我们当前这个状态是一个向量  $[V(s_1),V(s_2),\cdots,V(s_N)]^T$。我们可以写成迭代的形式。我们每一行来看的话，V 这个向量乘以了转移矩阵里面的某一行，然后再加上它当前的这个可以得到的 reward，然后就会回到它当前的这个价值。

当我们写成如下的矩阵形式后
$$
V = R+ \gamma PV
$$


我们可以直接得到一个`解析解(analytic solution)`，就通过矩阵求逆的过程，就可以把这个 V 的这个价值直接求出来。但是一个问题是这个矩阵求逆的过程的复杂度是 $O(N^3)$。所以就当我们状态非常多的时候，比如说从我们现在十个状态到一千个状态，到一百万个状态。那么当我们有一百万个状态的时候，这个转移矩阵就会是个一百万乘以一百万的一个矩阵。这样一个大矩阵的话求逆是非常困难的，所以这种通过解析解去解，只能对于很小量的MRP。

![](img/2.15.png)

接下来我们来求解这个价值函数。我们有这个迭代的方法来解这种状态非常多的 MRP。这里迭代的方法就有几种，比如说我们可以通过动态规划的方法，也可以通过蒙特卡罗的办法，就通过采样的办法去计算它。另外我们也可以通过 Temporal-Difference Learning 的那个办法。这个 `Temporal-Difference Learning` 叫 `TD Leanring`，就是动态规划和蒙特卡罗的一个结合。

![](img/2.16.png)

首先我们来看蒙特卡罗的办法来计算它的一个价值函数。蒙特卡罗就跟我们之前采用的这个方法是很类似，就说我们当得到一个MRP过后，我们可以从某一个状态开始，然后让它让把这个小船放进去，让它随波逐流，这样就会产生一个轨迹。产生了一个轨迹过后，就会得到一个奖励，那么就直接把它的 Discounted 的奖励 $g$ 直接算出来。算出来过后就可以把它积累起来，当积累到一定的轨迹数量过后，然后直接除以这个轨迹，然后就会得到它的这个价值。

比如说我们要算 $s_4$ 状态的一个价值，就可以从 $s_4$ 状态开始，随机产生很多轨迹，就产生很多小船，然后扔到这个转移矩阵里面去，然后它就会随波逐流，产生轨迹。每个轨迹，我们可以算到它的这个 return 。那么每个轨迹都会得到一个 return，让我们得到大量的 return 。比如说一百个、一千个的 return ，然后直接取一个平均，那么就可以等价于它现在 $s_4$ 这个价值。因为 $s_4$ 的价值 $V(s_4)$  定义了你未来可能得到多少的奖励。这就是蒙特卡罗采样的方法。

![](img/2.17.png)我们也可以用这个动态规划的办法，就通过这种一直去迭代它的 Bellman Equation，让它最后收敛，我们就可以得到它的一个状态。所以在这里算法二就是一个迭代的算法，通过这个 bootstraping 的办法，然后去不停地迭代这个 Bellman Equation。当这个最后更新的状态跟你上一个状态变化并不大的时候，这个更新就可以停止。那么我们就可以输出最新的 $V'(s)$ 作为它当前的状态。所以这里就是利用到了 Bellman Equation，就把 Bellman Equation 变成一个 Bellman Update，这样就可以得到它的一个价值。

## Markov Decision Process(MDP)

![](img/2.18.png)

相对于 MRP，`马尔可夫决策过程(Markov Decision Process)`多了一个 `decision`，其它的定义跟 MRP 都是类似的。这里我们多了一个决策，多了一个 action ，那么这个状态转移也多了一个 condition，就是你采取某一种行为，然后你未来的状态会不同。它不仅是依赖于你当前的状态，也依赖于在当前状态你这个 agent 它采取的这个行为会决定它未来的这个状态走向。对于这个价值函数，它也是多了一个条件，多了一个你当前的这个行为，就是说你当前的状态以及你采取的行为会决定你在当前可能得到的奖励多少。

![](img/2.19.png)

Policy 定义了在某一个状态应该采取什么样的行为，当我们知道当前状态过后，我们可以带入这个 policy function，那我们会得到一个概率，概率就代表了在所有可能的行为里面怎样去采取行动。就可能有 0.7 的概率往左走，有 0.3 的概率往右走，这样是一个概率的表示。另外这个策略也可能是确定的，它有可能是直接输出一个值，或者就直接告诉你当前应该采取什么样的行为，而不是一个行为的概率。然后这里我们有一个假设，就是这个概率函数应该是静态的(stationary)，不同时间点，你采取的行为其实都是对这个 policy function 进行采样。

![](img/2.20.png)

这里说明了 MDP 跟 MRP 的之间的一个转换，就是已知一个 MDP 以及一个 policy $\pi$ 的时候，我们可以把 MDP 转换成MRP。在 MDP 里面，转移函数 $P(s'|s,a)$  是基于它当前状态以及它当前的 action，因为我们现在已知它 policy function，就是说在每一个状态，我们知道它可能采取的行为的概率，那么就可以直接把这个 action 进行加和，直接把这个 a 去掉，那我们就可以得到对于 MRP 的一个转移，这里就没有 action。对于这个奖励函数，我们也可以把 action 拿掉，这样就会得到一个类似于 MRP 的奖励函数。

![](img/2.21.png)



这里我们看一看，MDP 里面的状态转移跟 MRP 以及 MP 的一个差异。

* 马尔可夫过程的转移是直接就决定，就你当前是 s，那么就直接通过这个转移概率决定了下一个状态是什么。
* 但对于 MDP，它的中间多了一层这个行为 a ，就是说在你当前这个状态的时候，首先要决定的是采取某一种行为。那么你会到了某一个黑色的节点。到了这个黑色的节点，因为你有一定的不确定性，当你当前状态决定过后以及你当前采取的行为过后，你到未来的状态其实也是一个概率分布。所以你采取行为后，你可能有多大的概率到达某一个未来状态，以及另外有多大概率到达另外一个状态。**所以在这个当前状态跟未来状态转移过程中这里多了一层决策性，这是 MDP 跟之前的马尔可夫过程很不同的一个地方。**在马尔科夫决策过程中，行为是由 agent 决定，所以多了一个 component，agent 会采取行为来决定未来的状态转移。

![](img/2.22.png)

* 顺着 MDP 的定义，我们可以把 state-value function，就是在 MDP 里面的价值函数也进行一个定义，它的定义是跟 MRP是类似的，但是这里 expectation over policy，就是这个期望是基于你采取的这个 policy ，就当你的 policy 决定过后，我们通过对这个 policy 进行采样来得到一个期望，那么就可以计算出它的这个价值函数。

* 这里我们另外引入了一个 `Q 函数(action-value function)`。这个 Q 函数定义的是某一个状态某一个行为，然后它有可能得到的这个 return 的一个期望，这里期望其实也是 over policy function。所以你需要对这个 policy function 进行一个加和，然后最后得到它的这个价值。
* 价值函数跟 Q 函数的关系，就是直接对价值函数中的行为函数进行加和，就可以得到这个价值。

![](img/2.23.png)

我们这里会得到一个 `Bellman Expectation Equation`，通过对它价值函数的定义，我们可以对它进行一个分解，我们就可以得到一个类似于之前 MRP 的 Bellman Equation，这里叫 Bellman Expectation Equation。 因为这里期望是期望于它所有的这个 policy 所有可能的行为都把它 marginalize 掉，然后得到 return。

对于 Q 函数，我们也可以做类似的分解，也可以得到对于 Q 函数的 Bellman Expectation Equation。

**Bellman Expectation Equation 定义了你当前状态跟未来状态之间的一个关联。**

![](img/2.24.png)

那我们进一步进行一个简单的分解。等式 8 和等式 9 代表了价值函数跟 Q 函数之间的一个关联。我们把等式 8 插入到等式 9，就可以得到等式 11，它象征了你当前时刻的 Q 函数跟未来时刻的 Q 函数之间的一个关联。也可以把等式 9 插入等式 8 中，得到等式 10。等式 10 代表了当前状态的价值跟未来状态价值之间的一个关联。

![](img/2.25.png)

这里有一个概念叫 `Backup`。Backup 类似于 bootstraping(拔靴自助) 之间这个迭代关系，就对于某一个状态，它的当前这个价值是跟它未来价值线性相关的。你可以看到我们这里有两层加和。第一层加和就是这个叶子节点，然后往上走一层的话，我们就可以把未来的这个价值 $s'$ backup 到黑色的节点。然后再有一层加和，第二层加和，这个加和是把 action 进行加和。得到黑色节点的价值过后，再往上 backup 一层，然后就会推到根节点的价值，根节点就是我们当前状态。所以 `Backup Diagram`  **定义了你未来下一时刻的状态跟你上一时刻的状态之间的一个关联。**

![](img/2.26.png)

同样对于 Q 函数，我们也可以进行这样的一个推导，就现在的根节点是这个 Q 函数的一个节点。这个 Q 函数是对于黑色的这个节点。我们下一时刻的这个 Q 函数是叶子节点，有四个黑色结点。那么我们这里也有两个加和。

第一层加和是先把这个叶子节点从黑节点推到这个白色的这个节点，进了它的这个状态，就当我们到达某一个状态过后，这个白色极点，然后再进行一个加和，这样就把它重新推回到当前节点的一个 Q 函数，所以这个等式就决定了未来 Q 函数跟当前 Q 函数之间的这个关联。

![](img/2.27.png)

当我们知道一个 MDP 以及要采取的策略 $\pi$ ，那我们计算价值函数的过程，就是 `policy evaluation`。就像我们在评估这个策略，我们会得到多大的奖励。Policy evaluation 在有些地方也被叫做 `prediction`，也就是预测你当前采取的这个策略最终会产生多少的价值。

![](img/2.28.png)

MDP，你其实可以把它想象成一个摆渡的人在这个船上面，她可以控制这个船的移动，这样就避免了这个船随波逐流。因为在每一个时刻，这个人会决定采取什么样的一个行为，这样会把这个船进行导向。MRP 跟马尔可夫链的过程的话，这个纸的小船会随波逐流，然后产生轨迹。MDP 的不同就是我们有一个 agent 去控制这个船，这样我们就可以尽可能多地获得奖励。

![](img/2.29.png)

我们再看下 policy evaluation 的例子，怎么在这个决策过程里面计算它每一个状态的价值。假设环境里面有两种行为：往左走和往右走。

现在的奖励函数应该是关于行为以及状态两个变量的一个函数。但我们这里就说，不管你采取什么行为，只要到达状态一，就有 5 的奖励。只要你到达状态 $s_7$ 了，就有 10 的奖励，中间没有任何奖励。假设我们现在采取的一个策略，这个策略是说不管在任何状态，我们采取的策略都是往左走，这里假设价值折扣因子是零，那么对于 deterministic policy，最后估算出的价值函数是一致的。怎么得到这个结果，我们可以直接在去 run 这个 iterative equation，就把这个 Bellman Expectation Equation 拿到这个里面来，然后不停地迭代，最后它会收敛。收敛过后，它的值就是它每一个状态的价值。

![](img/2.30.png)

再来看另外一个情况，就是如果折扣因子是 0.5，我们可以通过这个等式进行迭代：
$$
v_{t}^{\pi}(s)=\sum_{a} P(\pi(s)=a)\left(r(s, a)+\gamma \sum_{s^{\prime} \in S} P\left(s^{\prime} \mid s, a\right) v_{t-1}^{\pi}\left(s^{\prime}\right)\right)
$$
然后就会得到它的状态。另外一个练习的例子，就是说我们现在采取的 policy 在每个状态，我们有 0.5 的概率往左走，有 0.5 的概率往右走，那么放到这个状态里面去如何计算。其实也是把这个 Bellman Expectation Equation 拿出来，然后进行迭代就可以算出来了，就当我们开始的时候，我们可以初始化。初始化这个不同的 $v(s')$ 都会有一个值，那么放到这个里面去迭代，最后它的 $v$ ，然后就会算出来。

![](img/2.31.png)

接下来给大家介绍 MDP 的 `prediction` 和 `control`，这两个问题是 MDP 里面的核心问题。

* Prediction 是说给定一个 MDP 以及一个 policy $\pi$ ，去计算它的 value function，就等于每个状态它的价值函数是多少。
* Control 这个问题是说我们去寻找一个最佳的一个策略，它的 input 就是MDP，输出是通过去寻找它的最佳策略，然后同时输出它的最佳价值函数(optimal value function)以及它的这个最佳策略(optimal policy)。
* 在 MDP 里面，prediction 和 control 都可以通过这个动态规划去解决。

![](img/2.32.png)

首先我们来看一下`动态规划`。动态规划是说我们把可以把一个问题分解成一个最佳子结构，当我们可以把一些子结构都可以解决的话，那么它就可以组成一个最优的解。MDP是满足动态规划的要求的，就是在 Bellman Equation 里面，我们可以把它分解成一个递归的一个结构。当我们把它分解成一个递归的结构的时候，如果我们的子问题子状态能得到一个值，那么它的未来状态因为跟子状态是直接相连的。那我们也可以继续推算出来。所以这个价值函数就可以储存它以及重用它的最佳的解。所以动态规划是解 MDP prediction 和 control 一个非常有效的方式。

![](img/2.33.png)

首先看一下 policy evaluation，就是当给定一个 MDP 的时候，我们有一个事先定好的 policy。那么我们可以获得多少的价值。就对于当前这个策略，我们可以得到多大的这个 value function。这里一个方法是说，我们直接把这个 Bellman Expectation Backup，这个等式拿出来，变成一个迭代的过程，这样反复迭代直到收敛。这样就可以计算它的一个过程。这个迭代过程是可以看作是 `synchronous backup` 的一个过程。等式 14 说的就是这个 Bellman Expectation Backup，我们把这个转换成一个动态规划的迭代。当我们得到上一时刻的 $v_t$ 的时候，那我们下一时刻就通过这个递归的一个关系，我们可以推出下一时刻的这个值，那么反复去迭代它，最后它的值就是从 $v_1,v_2$，到最后收敛过后这个值。这个值就是我们当前给定的 policy 对应的价值函数。

![](img/2.34.png)

Policy evaluation 的核心思想就是直接把这个 Bellman expectation backup，把如下的等式拿出来，
$$
v_{t+1}(s)=\sum_{a \in \mathcal{A}} \pi(a \mid s)\left(R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} P\left(s^{\prime} \mid s, a\right) v_{t}\left(s^{\prime}\right)\right)
$$
然后反复迭代，然后就会得到一个收敛的价值函数的值，这个函数因为我们已经给定了它的这个 policy  function，那我们可以直接把它简化成一个 MRP 的表达形式，那么它的形式就更简洁一些，就相当于我们把这个 $a$  去掉。然后这样它就只有价值函数跟转移函数了。那我们通过去迭代这个更简化的一个函数，这样我们也可以得到它每个状态的价值，因为不管是在 MRP 以及 MDP，它的这个价值函数包含的这个变量都是只跟这个状态有关就相当于进入某一个状态，未来可能得到多大的价值。

![](img/2.35.png)

比如现在这个环境是一个 small gridworld 的例子。这个 agent 的目的是从某一个状态开始，然后到达终点状态。它的终止状态就是左上角跟右上角，这里总共有 14 个状态，因为我们把每个位置就是用一个状态来表示。然后这个 agent 它采取的行为，我们说它的这个 policy function 就直接先给定了，它在每一个状态都是随机游走，它们在每一个状态就是上下左右行走。它在边缘状态的时候，比如说在第四号状态的时候，它往左走的话，它是依然存在第四号状态，我们加了这个限制。

这里我们给的奖励函数就是说你每走一步，就会得到一个负的奖励。所以这个 agent 需要尽快地到达这个终止状态。状态之间的转移也是确定的。比如从第六号状态往上走，它就会直接到达第二号状态。很多时候有些环境是 `probabilistic` 的话，就是说 agent 在第六号状态，它选择往上走的时候，有可能地板是滑的，然后它可能滑到第三号状态或者第一号状态，这就是有概率的一个转移。但这里把这个环境进行了简化，从六号往上走，它就到了二号。所以直接用这个迭代来解它。因为我们已经知道每一个概率以及它的这个概率转移，那么就直接可以进行一个简短的迭代，然后就会算出它每一个状态的价值。

![](img/2.36.png)

![](img/2.37.png)

我们再来看一个动态的例子。这里有很多格子，每个格子都代表了一个状态。在每个格子里面有一个初始值零。然后在每一个状态，它还有一些箭头，这个箭头就是说它在当前这个状态应该采取什么样的策略。我们这里采取一个随机的策略，不管它在哪一个状态，它上下左右的概率都是相同的。比如在某个状态，它都有上下左右 0.25 的概率采取某一个行为，所以它是一个完全随机的一个行为。

![](img/2.38.png)

在这样的环境里面，我们想计算它每一个状态的价值。我们也定义了它的 reward function，你可以看到有些状态上面有一个 R 的值。比如我们这边有些值是为负的，然后在这个棋盘的中间这个位置，可以看到有一个 R 的值是 1.0，为正的一个价值函数。 所以每个状态对应了一个值，然后有一些状态没有任何值，就说明它的这个 reward function，它的奖励是为零的。

所以，当我们开始做这个 policy evaluation，policy evaluation是一个不停迭代的过程。当我们初始化的时候，所有的 $v(s)$ 都是 0。我们现在迭代一次，迭代一次过后，你发现有些状态上面，值已经产生了变化。比如说那些有奖励的值，比如有些状态的值的 R 为 -1，迭代一次过后，它就会得到 -1 的这个奖励。对于中间这个绿色的，因为它的奖励为正，所以它是 + 1 的状态。

![](img/2.39.png)

所以当迭代第一次的时候，$v(s)$ 某些状态已经有些值的变化。

![](img/2.40.png)

我们再迭代一次(one sweep)，然后发现它就从周围的状态也开始有值。因为周围状态跟之前有值的状态是临近的，所以它就相当于把旁边这个状态转移过来。所以当我们逐渐迭代的话，你会发现这个值一直在变换。等迭代了很多次过后，很远的这些状态的价值函数已经有些值了，而且你可以发现它这里整个过程呈现逐渐扩散开的一个过程，这其实也是 policy evaluation 的一个可视化。当我们每一步在进行迭代的时候，就远的状态就会得到了一些值，就逐渐从一些已经有奖励的这些状态，逐渐扩散，当你 run 很多次过后，它就逐渐稳定下来，最后值就会确定不变，这样收敛过后，每个状态上面的值就是它目前得到的这个 value function 的值。

![](img/2.41.png)

Policy evaluation 是说我们给定一个 MDP 以及给定一个 policy，然后我们可以估算出它的价值函数。那么这个问题的另外一方面是说如果我们只有一个 MDP，如何去寻找一个最佳的策略，然后可以得到一个`最佳价值函数(Optimal Value Function)`。Optimal Value Function 的定义是说，我们去搜索一种 policy $\pi$ ，然后我们会得到每个状态它的状态值最大的一个情况，$v^*$ 就是到达每一个状态，它的值的极大化情况。在这种极大化情况上面，我们得到的策略就可以说它是最佳策略(optimal policy)。optimal policy 使得每个状态，它的状态函数都取得最大值。所以当我们说某一个 MDP 的环境被解了过后，就是说我们可以得到一个 optimal value function，然后我们就说它被解了。在这种情况下面，然后我们它的最佳的价值函数是一致的，就它达到了这个 upper bound，它的值是一致的，但是这里可能有多个最佳的 policy，多个 policy 可以取得相同的最佳价值。

![](img/2.42.png)

怎么去寻找这个最佳的 policy ，这里一个隐含条件是当我们取得最佳的价值函数过后，我们其实可以通过对这个 Q 函数进行极大化，然后得到最佳的价值。当所有东西都收敛过后，因为 Q 函数是关于状态跟动作的一个函数，所以对某一个状态采取一个行为，然后可以使得这个 Q 函数最大化，那么就这个行为就应该是最佳的行为。所以当我们能优化出一个 Q 函数，我们可以直接在这个 Q 函数上面取一个让这个 action 最大化的值，然后我们就可以直接提取出它的最佳策略。

![](img/2.43.png)

这里一种策略搜索办法是我们可以去穷举。假设我们有有限多个状态、有限多个行为可能性，那么每个状态我们可以采取这个 A 种行为的策略，那么总共就是 $|A|^{|S|}$ 个可能的 policy。那么有一种方法是直接可以把这个把穷举一遍，然后算出每种策略的 value function，然后对比一下可以得到最佳策略。但是一个问题是这样的穷举非常没有效率，所以我们要采取另外的一些办法，所以在解这个搜索最佳策略的方法有两种比较常用的方法：一种是叫 `policy iteration`，另外一种是叫 `value iteration` 的一个方法。

![](img/2.44.png)

所以我们在寻找这个最佳策略的过程就是 MDP 的控制过程，MDP Control 说的就是怎么去寻找一个最佳的策略，然后我们可以得到一个最大的价值函数。对于一个事先定好的 MDP 过程，当这个 agent 去采取策略的时候，我们可以说它这个最佳策略一般都是确定的。而且它是 stationary，它不会随着时间的变化。但是不一定是 unique，多种行为然后都会取得相同的这个这个价值。

![](img/2.45.png)

首先我们来看一下 policy iteration。policy iteration 也是一个迭代算法。它主要由两个步骤组成，

* **第一个步骤是 policy evaluation**，就跟我们之前说的这个评价一个已有的这个价值函数的价值是一致的，就是我们当前我们在优化这个 policy $\pi$ ，所以在优化过程中得到一个最新的这个 policy 。让我们先保证这个 policy 不变，那么去估计它出来的这个价值。给定当前的policy function，去估计这个 v 函数。
* 取得 v 函数过后，我们可以进一步推算出它的 Q 函数。得到 Q 函数过后，那我们就直接去取它的极大化。在 Q 函数上面取极大化，**这样我们就有了第二步骤：改进它的策略。**通过在这个 Q 函数上面做一个贪心的搜索，这样就会进一步改进它的策略。
* 这两个步骤就一直是在迭代进行，所以在这个 policy iteration 里面，在初始化的时候，我们有一个初始化的 $V$ 和 $\pi$ 。然后就是在这两个过程之间迭代，左边这幅图上面这根曲线就是我们当前这个 v 的值，下面是 policy 的值。就跟踢皮球一样，我们先给定当前已有的这个 policy function，然后去算它的这个 v。算出 v 过后，我们会得到一个 Q 函数，Q 函数我们采取 greedy 的策略，这样我们有踢皮球，踢回这个 policy 。然后就会进一步改进那个 policy ，得到一个改进的 policy 过后，它还不是最佳的，我们再进行 policy evaluation，然后又会得到一个新的 value function。基于这个新的 value function 再进行 Q 函数的极大化 ，这样就逐渐迭代，然后就会得到收敛。

![](img/2.46.png)

这里再来看一下第二个步骤 `policy improvement`，我们是如何改进它的这个策略。当我们得到这个 v 值过后，我们就可以通过这个 reward function 以及状态转移把它的这个 Q-function 算出来。对于每一个状态，第二个步骤会得到它的一个新一轮的这个 policy ，就在每一个状态，我们去取使它得到最大值的 action。你可以把这个 Q 函数看成一个 Q-table。横轴是它的所有状态，纵轴是它的可能的 action。Q 函数得到过后，`Q-table` 就得到了。

那么对于某一个状态，每一列里面我们会取最大的那个值，最大值对应的那个 action 就是它现在应该采取了更佳的action。所以你看这里下面这个 arg max 操作就说在每个状态里面，我们去采取一个 action，这个 action 就是能使这一列的 Q 最大化的那个动作。

![](img/2.47.png)

当我们一直在采取这个 arg max 这个操作的时候，我们会得到一个单调的递增。我们通过采取这种 greedy ，这种 arg max 这个操作，就会得到更好的或者不变的 policy，而不会使它这个价值函数变差。所以当这个改进停止过后，我们就会得到一个最佳策略。

![](img/2.48.png)

当改进停止过后，我们取它极大化的这个 action 之后，它直接就会变成它的这个价值函数。所以我们在这里有了一个新的一个等式，就叫 `Bellman Optimality Equation`。这个 Bellman Optimality Equation 满足的时候，是说整个 MDP 已经到达最佳的状态。它到达最佳状态过后，对于我们这个 Q 函数，我们取它最大的 action 时候的那个值，就是直接等于它的最佳的这个 value function，这个条件只有当整个状态已经收敛过后，已经得到一个最佳的 policy 的时候，然后它是满足的。

![](img/2.49.png)

最佳的价值函数到达过后，这个 Bellman Optimlity Equation 就会满足。我们满足过后，就有这个 max 操作，当我们取最大的这个 action 的时候对应的那个值就是当前那个状态的最佳的价值函数。

我们可以把第一个等式插入到第二个等式里面去，然后就会得到这个 Q 函数之间的这个转移。它下一步这个状态我们取了这个 max 这个值过后，就会也跟它下一个最佳的这个状态等价。

Q-learning 是基于 Bellman Optimality Equation 来进行的，当取它最大的这个状态的时候，它会满足下面这个等式：
$$
q^{*}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} P\left(s^{\prime} \mid s, a\right) \max _{a^{\prime}} q^{*}\left(s^{\prime}, a^{\prime}\right)
$$


![](img/2.50.png)

Value iteration 说的是我们把 Bellman Optimality Equation 当成一个 update rule 来进行，之前我们是说上面这个等式只有当整个状态已经到达最佳状态的时候，然后才满足。但这里可以把它转换成一个 backup 的等式。 Backup 就是说一个迭代的等式，我们不停地去迭代 Bellman Optimality Equation，到了最后，它能逐渐趋向于最佳的策略，所以这也是 value iteration 算法的精髓，就是我们去为了得到最佳的 $v^*$ ，对于每个状态它的 $v^*$ 这个值，我们直接把这个 Bellman Optimality Equation 进行迭代，迭代了很多次之后它就会收敛。

![](img/2.51.png)

Value iteration 算法的目的是为了得到一个最佳的策略。一个解法是直接把这个 `Bellman Optimality backup`，把它这个等式拿进来进行迭代，迭代很多次，收敛过后得到的那个值就是它的最佳的那个值。所以这个算法开始的时候，它是先把所有值初始化，通过每一个状态，然后它会进行这个迭代。

把等式 22 插到等式 23 里面，就是Bellman Optimallity backup 的那个等式。有了这个等式过后，然后进行不停地迭代，迭代过后，然后收敛。然后就会得到这个 $V^*$ 。当我们有这个 $V^*$ 过后，一个问题是如何进一步推算出它的最佳策略。最佳策略的话，我们可以直接用 arg max，就先把它的 Q 函数重构出来，重构出来过后，每一个列对应的最大的那个 action 就是它现在的最佳策略，这样就可以把最佳策略从最佳价值函数里面推导出来。

![](img/2.52.png)

上图是一个可视化的过程。在一个 grid world 中，不管你在哪一个位置开始，我们都希望能够到 goal 的这个点，左上角的那个点。因为它是一个迭代过程，然后这里可视化了从  $v_1$ 到 $v_7$  每一个状态的值的变化，它的这个值逐渐在变化。而且因为它每走一步，就会得到一个负的值，所以它需要尽快地到达左上角，可以发现离它越远的那个值就越大。$v_7$ 收敛过后，右下角那个值是 -6，也就相当于它要走六步，才能到达最上面那个值。而且离这个目的地越近，它的价值越大。

![](img/2.53.png)

![](img/2.54.png)

我们来看一个 MDP 控制的 Demo。首先来看这个 policy iteration。之前的例子，它们在每个状态都是采取固定的随机策略，就每个状态都是 0.25 的概率往上往下往左往右，这里没有策略的改变。但是我们现在想做 policy iteration，就是想每个状态都进行改变。Policy iteration 的过程是一个迭代过程。

![](img/2.55.png)

我们先在这个状态里面 run 一遍 policy  evaluation，就得到了一个 value function，每个状态都有一个 value function。

![](img/2.56.png)

现在进行 policy improvement，按 policy update。按这个 policy update 过后，你可以发现有些格子里面的这个 policy 已经产生变化。比如说对于中间这个-1的这个状态，它的最佳策略是往下走。当你到达这个状态后，你应该往下，这样就会得到最佳的这个值。让旁边这个绿色旁边的这个方块，它的策略也改变了，它现在选取的最佳策略是往左走，在当前状态的时候，最佳策略应该是往左走才对。

![](img/2.57.png)

我们再 run 下一轮的 policy evaluation，你发现它的这个值又被改变，很多次过后，然后它会更新。

![](img/2.58.png)

我们再 run policy update，你发现每个状态里面的值基本都改变，它不再是上下左右随机在变了，它会选取一个最佳的策略。

![](img/2.59.png)

我们再 run 这个 policy evaluation，它的值又再不停地变化，变化之后又收敛了。

![](img/2.60.png)


我们再来 run 一遍 policy update。现在它的值又会有变化，就在每一个状态，它的这个最佳策略也会产生一些改变。

![](img/2.61.png)

再来在这个状态下面进行改变，现在你看基本没有什么变化，就说明整个 MDP 已经收敛了。所以现在它每个状态的值就是它当前最佳的 value function 的值以及它当前状态对应的这个 policy 已经是最佳的 policy。我们可以简单来看，比如说现在我们在右上角这个 0.38 的这个位置，现在我们直接就可以根据它每个状态的这个值，比如现在右上角，然后它说现在应该往下走，我们往下走一步。它又说往下走，然后再往下走。现在我们有两个选择，一个是往左走，一个往下走。我们现在往下走，随着这个箭头的指示，我们就会到达中间 1.20 的一个价值的一个状态。如果能达到这个状态的话，我们会得到很多 reward 。这个说明了 policy iteration 的一个过程可以把 gridworld 解决掉。解决掉的意思是说，不管在哪个状态，都可以顺着它这个状态对应的最佳的这个策略来到达可以获得最多奖励的一个状态。

![](img/2.62.png)

我们再用 value iteration 来解 MDP，点第 3 个 value iteration。 当它的这个值确定下来过后，然后它会产生它的最佳状态，这个最佳状态跟 policy iteration 得出来的最佳策略是一致的，就可以得到一个最佳的一个策略。然后在每个状态，我们跟着这个最佳策略走，就会到达最多可以得到奖励的一个状态。

![](img/2.63.png)

这个 Demo 里面是一个代码，就是为了解一个叫 `FrozenLake` 的例子，这个例子是 OpenAI Gym 里的一个环境，跟 gridworld 很像，不过它每一个状态转移是一个 probability。

![](img/2.64.png)

我们再来对比下 policy iteration 和 value iteration，这两个算法都可以解 MDP 的控制问题。

* Policy iteration 由两部分组成：policy  evaluation 和 policy improvement。它很清楚地把这个过程分成了两步，就首先对于当前已经搜索到的策略函数，然后对它进行一个估值，得到估值过后，把 Q 函数算出来，我们进一步进行改进。

*  但对于 value iteration 的话，它是直接把 Bellman Optimality Equation 拿进来，然后直接去寻找最佳的 value function，没有 policy function 在这里面，当我们把这个 optimal value function 算出来过后，那我们可以在最后再执行一步这个提取过程，最佳策略提取过程。这样就可以把它的最佳策略抽取过来。

![](img/2.65.png)

这里是一个总结，就对于 MDP 里面的 prediction 和 control  都是用动态规划来讲，我们其实采取了不同的 Bellman Equation。

* 如果是一个 prediction 的问题，即 policy evaluation  的问题，那就直接是把这个 Bellman Expectation Equation 拿进来，就是不停地 run 这个 Bellman Expectation Equation，这样我们就可以去估计出给定的这个策略，然后可以得到的价值函数。
* 对于 control，
  * 如果采取的算法是 policy  iteration，那这里直接是用的 Bellman Expectation Equation 。把它分成两步，先上它的这个价值函数，再去优化它的策略，然后不停迭代。这里用到的只是 Bellman Expectation Equation。
  * 如果采取的算法是 value iteration，那么这里用到的 Bellman Equation 就是 Bellman Optimality Equation，通过 arg max 这个过程，不停地去 arg max 它，最后它就会达到最优的状态。

